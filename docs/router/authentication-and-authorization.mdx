---
title: "Authentication & Authorization"
icon: camera-cctv
description: "Set up authentication and authorization for incoming requests"
---

<Info>
  Authorization directives can be used in your schema to define granular authorization rules on the field definition level. Documentation can be found at [@authenticated](/federation/directives/authenticated) and [@requiresScopes](/federation/directives/requiresscopes).
</Info>

Cosmo router supports authenticating incoming requests using [JWKS](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-key-sets) authentication. The JSON Web Key Set (JWKS) is a set of keys that contains the public keys used to verify any JSON Web Token (JWT) issued by the authorization server and signed using a [signing algorithm](https://auth0.com/docs/tokens/concepts/signing-algorithms).

To enable an authentication provider, add it to your configuration

## Current Configuration

In the current router version, the configuration and behavior of authentication have been redesigned. Instead of specifying a configuration per JWKS endpoint, you can now list multiple endpoints where all header rules apply to. Each JWKS endpoint can optionally specify a whitelist of supported JWT algorithms.

### Configuration

<CodeGroup>
  ```yaml config.yaml
  authentication:
    jwt:
      jwks:
        - url: https://example.com/.well-known/jwks.json
          refresh_interval: 1m
          algorithms: ["RS256"]
          refresh_unknown_kid:
            enabled: true
            max_wait: 2m
            interval: 30s
            burst: 5
        - url: https://example2.com/.well-known/jwks.json
          refresh_interval: 2m
          # optional list of allowed algorithms per JWKS
          algorithms: ["RS256", "EdDSA", "HS512"]
          audiences:
            - http://aud1
            - http://aud2
        - symmetric_algorithm: HS256
          secret: <your_secret>
          header_key_id: some-key-id
      header_name: Authorization # Optional, Authorization is the default value
      header_value_prefix: Bearer # Optional, Bearer is the default value
      header_sources:
        - type: header
          name: X-Auth-Token
          value_prefixes: [Token, MyToken]
        - type: header
          name: X-Authorization
  ```
</CodeGroup>

The router configuration facilitates the setup of multiple JWKS (JSON Web Key Set) endpoints, each customizable with distinct retrieval settings. It allows specification of supported JWT (JSON Web Token) algorithms per endpoint. It also allows the use of secrets for symmetric algorithms, as it would be a security risk to expose them over a JWKS endpoint. Centralizing header rules application across all keys from every JWKS endpoint simplifies management. This setup grants centralized control while offering flexibility in the retrieval and processing of keys.

For more information on the attributes, visit the auth configuration parameter section page [here](/router/configuration#authentication).



## Old Router configuration (\< 0.168.1)

<CodeGroup>
  ```yaml config.yaml
  authentication:
    providers:
      - name: My Auth Provider # Optional, used for error messages and diagnostics
        jwks: # JWKS provider configuration
          url: https://example.com/.well-known/jwks.json # URL to load the JWKS from (Authorization server)
          header_names: [Authorization] # Optional, Authorization is the default value
          header_value_prefixes: [Bearer] # Optional, Bearer is the default value
          refresh_interval: 1m # Optional, How often the JWK is refreshed

  ```
</CodeGroup>

Using multiple authentication providers is also supported. If authentication with any of the providers succeeds, the claims from the token are decoded and made available through the request pipeline. Notice that providers are tried in the same order as they are defined in the configuration and once a provider authenticates a request, no other providers are tried.

### Enforce authentication

By default, requests without authentication information are allowed. Only requests with invalid authentication information (e.g. an incorrectly signed token) produce a `403 Forbidden` response. To disable anonymous requests, use the Authorization configuration:

<CodeGroup>
  ```yaml config.yaml
  authorization:
    require_authentication: true
  ```
</CodeGroup>

This causes requests without authorization information to produce a `401 Unauthorized`

Authentication information is also available to custom modules. See [Access Authenticated Information](/router/custom-modules#access-authentication-information).

### Forwarding authentication headers

By default, the router won't forward authentication headers to subgraphs, but if desired this can be configured using [Proxy capabilities](/router/proxy-capabilities).


### Refreshing Unknown KIDs on demand
Setting `refresh_unknown_kid.enabled` as `true`, would enable the automatic refreshing of KIDs whenever a valid token with an unknwon KID is passed to the router. The router will assume that the JWKs has not been rotated and will call the JWKs endpoint hoping the JWKs with the matching KID has been added. However to prevent overloading the JWKs endpoint we ratelimit this feature, ratelimiting works based on the "burst" value specified.

Let's say that the burst value was 1 and we sent 6 requests, this means after the 1st request, we need to wait 30 seconds (the value of `refresh_unknown_kid.interval`) before sending the next request with an unknown KID. If we however do end up sending another request with an unknown KID before the duration has elapsed, the response of that request will be blocked until it has elapsed. Likewise, since we can process only one request at a time, if we send 6 requests simultaneously, with an interval of `30s`

The 2nd request will block for 30s (30s * 1)
The 3rd request will block for 60s (30s * 2)
The 4th request will block for 90s (30s * 3)
The 5th request will block for 120s (30s * 4)
The 6th request will block for 150s (30s * 5)

The `max_wait` value, is used to prevent the ballooning of waits. If the max wait was set to `110s`, for the 5th and 6th requests, we already can compute and know that they will be blocked for more than `110s`, as such we immediately stop searching for unknown KIDs and error out.

