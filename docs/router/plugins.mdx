---
title: 'gRPC Plugins'
description: 'Bridge any service into your GraphQL federation with secure, performant gRPC plugins — simplifying architecture while enabling type-safe integration of REST, databases, and legacy systems'
icon: "plug"
---

## Introduction

The Cosmo Router supports extending its functionality with gRPC plugins, allowing you to implement subgraphs directly within the router process. This architecture provides significant performance benefits by eliminating network hops while maintaining clean separation of concerns.

<Frame type="color">
  <div className="flex gap-3 items-center">
    <div className="flex-shrink-0">
      <img src="/images/router/grpc-plugins.png" width="100" />
    </div>
    <div>
      <div className="font-semibold">Explore the demo repository</div>
      <div className="text-sm">Check out our <a href="https://github.com/wundergraph/cosmo-plugin-demo" target="_blank" rel="noopener">cosmo-plugin-demo</a> repository for a working example of gRPC plugins in action.</div>
    </div>
  </div>
</Frame>

## What are gRPC Plugins?

gRPC plugins are extensions that run as separate processes and communicate with the Cosmo Router over Google's Remote Procedure Call ([gRPC](https://grpc.io/)) protocol.

Running as separate processes provides critical fault isolation - if a plugin crashes or encounters a fatal error, it won't bring down your router process.

gRPC plugins implement the GraphQL resolvers while providing:

<CardGroup cols={2}>
  <Card title="Higher Performance" icon="bolt">
    Eliminate network hops by running resolvers in-process with the router
  </Card>
  <Card title="Lower Latency" icon="gauge-high">
    Reduce end-to-end request time with direct resolver calls
  </Card>
  <Card title="Resource Efficiency" icon="server">
    Reduce infrastructure costs by consolidating services
  </Card>
  <Card title="Clean Architecture" icon="diagram-project">
    Maintain separation of concerns with modular plugin design
  </Card>
</CardGroup>

The plugin architecture is built on HashiCorp's battle-tested [go-plugin framework](https://github.com/hashicorp/go-plugin), which powers production systems like Vault and Terraform with millions of deployments worldwide. This provides enterprise-grade reliability, secure process isolation, and proven stability for your GraphQL infrastructure.

## Motivation

The biggest pain point in adopting GraphQL isn't GraphQL itself—it's the steep learning curve and fragmented subgraph tooling across languages and platforms.

<CardGroup cols={1}>
  <Card title="Simplify GraphQL Implementation" icon="wand-magic-sparkles">
    While everyone understands the value of "one schema, one query," building and maintaining production-grade subgraphs across diverse environments remains challenging. Spec support, runtime performance, and type safety depend on your subgraph framework quality.
  </Card>

  <Card title="Design with GraphQL, Implement with gRPC" icon="code">
    Our approach combines GraphQL's schema-first flexibility with gRPC's performance and reliability. Using the same plugin system that powers HashiCorp Vault and Terraform, you can develop subgraphs in any language and run them directly in the Cosmo Router.
  </Card>

  <Card title="Proto-Based Code Generation" icon="bolt">
    The strict typing and automatic code generation from Protocol Buffers (proto) definitions provides an immense productivity boost, especially in the era of generative AI. The generated proto-based gRPC code creates a strongly-typed foundation that AI tools can more effectively understand, extend, and modify, reducing development time and errors while ensuring consistent API implementation.
  </Card>
</CardGroup>

### Benefits Over Traditional Subgraphs

When compared to traditional standalone subgraphs, gRPC plugins offer substantial technical advantages:

<CardGroup cols={2}>
  <Card title="Reduced Latency" icon="gauge-high">
    Eliminates network round-trips between the router and subgraph for faster query execution
  </Card>
  <Card title="Simplified Deployment" icon="cloud-arrow-up">
    Fewer moving parts means simpler deployments and maintenance with all subgraphs running in the router process
  </Card>
  <Card title="Reduced Infrastructure Costs" icon="dollar-sign">
    Consolidate services to reduce overall resource consumption and operational complexity
  </Card>
  <Card title="Direct API Bridging" icon="bridge">
    Easily connect legacy REST APIs, databases, and other services to your graph without building standalone GraphQL services
  </Card>
</CardGroup>

This architecture gives you a unified development experience with consistent tooling across all your subgraphs while enabling seamless integration with your existing infrastructure.

## How It Works

The gRPC plugin architecture works by:

1. **Plugin Registration**: Plugins are registered with the Cosmo Router at startup
2. **Schema Integration**: The plugin's schema is integrated into the federated graph
3. **Request Handling**: When the router receives a GraphQL request, it routes relevant parts to the appropriate plugins
4. **Cross-Process Communication**: Plugins run in separate processes and communicate with the router via gRPC
5. **Response Assembly**: The router assembles the complete response from all resolvers

## Use Cases

gRPC plugins are ideal for:

- **Legacy API Integration**: Wrap existing REST, SOAP, or other APIs behind GraphQL types
- **Performance-Critical Paths**: Implement frequently accessed resolvers with minimal overhead
- **Simplified Architecture**: Reduce the number of services in your deployment
- **Resource Optimization**: Reduce cloud costs by consolidating services

## Limitations

While powerful, gRPC plugins have some considerations:

- **Language Support**: Currently, only Go is supported for plugin development
- **Process Isolation**: Plugins run in separate processes thanks to HashiCorp go-plugins, providing stability and fault isolation
- **Deployment Coupling**: Plugins must be deployed with the router rather than independently

## Bootstrapping a gRPC Plugin

Cosmo provides a set of CLI tools to simplify the process of creating, building, and testing gRPC plugins. These tools handle much of the boilerplate code generation and build process for you.

### Prerequisites

Before using the plugin CLI tools, make sure you have:
- [WunderGraph Cosmo CLI](/cli) installed
- Go installed for Go-based plugins

### Creating and Building Plugins

The Cosmo CLI provides the following commands for working with plugins:

- **[`wgc plugin init`](/cli/plugin/init)**: Scaffolds a new gRPC plugin project
- **[`wgc plugin build`](/cli/plugin/build)**: Generates code and builds the plugin
- **[`wgc plugin test`](/cli/plugin/test)**: Runs tests for your plugin

For detailed documentation on each command, visit the [CLI Plugin Commands](/cli/plugin) section.

### Typical Workflow

Here's a simplified workflow for creating a gRPC plugin and configuring the router to use it:

```bash
# Initialize a new plugin
wgc plugin init users -d ./plugins

# Customize the schema and implementation
# Edit `./plugins/users/src/schema.graphql` and `./plugins/users/src/main.go`

# Generate the artifacts and Go code only. Now you can implement your gRPC resolvers.
wgc plugin build --generate-only ./plugins/users

# Build the plugin. This will generate the Go code and compile the plugin.
wgc plugin build ./plugins/users

# Test the plugin. Every boilerplate plugin should have a test file.
wgc plugin test ./plugins/users
```

Next, you need to define your `graph.yaml` file that references your plugin:

```yaml graph.yaml
version: 1
subgraphs:
  - name: products
    routing_url: http://localhost:3011/graphql
    schema:
      file: ../subgraphs/products/schema.graphql
  - name: users
    plugin:
      version: 0.0.1
      path: plugins/users
```

In this example:
- A traditional "products" subgraph is referenced by its URL and schema file
- The "users" subgraph is implemented as a plugin, referencing the path to the built plugin

Next, you need to create the router execution config:

```bash
wgc router compose -i graph.yaml -o config.json
```

Once composed, you can configure your router to use the plugin and execution config in your `config.yaml`:

```yaml config.yaml
execution_config:
  file:
    # The path to the execution configuration file
    # This file is generated by the `wgc router compose` command
    path: ./__schemas/config.json

plugins:
  enabled: true
  path: "plugins" # The path to the plugins directory
```

### Plugin Directory Structure

When you initialize a plugin using `wgc plugin init`, it creates a directory structure like this:

```text Directory Structure
my-plugin/
├── README.md                      # Documentation and getting started guide
├── go.mod                         # Go module definition
├── src/
│   ├── schema.graphql            # GraphQL schema defining your subgraph
│   ├── main.go                   # Main implementation file for your plugin
│   └── main_test.go              # Test file for your plugin
└── generated/
    ├── mapping.json              # GraphQL to gRPC mapping
    ├── service.proto             # Protocol Buffers definition
    └── service.proto.lock.json   # Lock file for Proto generation
```

For more details on the directory structure and build process, see the [`wgc plugin init`](/cli/plugin/init) documentation.

## Conclusion

gRPC plugins for the Cosmo Router provide a powerful way to implement high-performance subgraphs that communicate with the router via a secure cross-process architecture. By leveraging the battle-tested HashiCorp go-plugin framework while maintaining clean separation of concerns, they offer the best of both worlds for many use cases.

For complex systems, consider a hybrid approach: use gRPC plugins for performance-critical paths and traditional subgraphs for areas that require independent scaling or deployment.