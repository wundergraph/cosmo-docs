---
title: 'MCP Gateway'
description: 'Integrate your GraphQL API with AI models using the Model Context Protocol (MCP)'
icon: "robot"
---

# AI Integration with Model Context Protocol (MCP)

## Introduction

The Model Context Protocol (MCP) server in WunderGraph Cosmo Router enables seamless integration between your GraphQL API and AI models such as ChatGPT, Claude, and other Large Language Models (LLMs). This powerful feature allows AI agents to discover, understand, and interact with your GraphQL API in a structured and secure way.

<Frame>
  <img src="/images/router/mcp-architecture.png" />
</Frame>

## What is MCP?

MCP (Model Context Protocol) is a protocol designed to help AI models interact with your APIs by providing context, schema information, and a standardized interface. The Cosmo Router implements an MCP server that exposes your GraphQL operations as tools that AI models can use.

<Info>MCP enables AI models to understand and interact with your GraphQL API without requiring custom integration code for each model.</Info>

The Cosmo MCP Server builds on top of the concept of persisted operations (also known as persisted queries or trusted documents). Instead of allowing AI models to execute arbitrary GraphQL operations, it exposes a predefined set of validated and approved operations. This provides a secure and controlled way for AI systems to interact with your data while maintaining tight control over what operations can be executed.

Here's what enabling MCP in your Cosmo Router provides:

<CardGroup cols={2}>
  <Card title="API Discovery" icon="magnifying-glass">
    Make your GraphQL API automatically discoverable by AI models like OpenAI, Claude, and Cursor
  </Card>
  <Card title="Rich Metadata" icon="tag">
    Provide detailed schema information and input requirements for each operation
  </Card>
  <Card title="Secure Access" icon="shield-check">
    Enable controlled, precise access to your data with operation-level granularity
  </Card>
  <Card title="AI Empowerment" icon="robot">
    Empower AI assistants to work with your application's data through a standardized interface
  </Card>
</CardGroup>

## Why combining GraphQL + MCP is Revolutionary

The integration of GraphQL with MCP creates a uniquely powerful system for AI-API interactions:

- **Precise data selection**: GraphQL's nature allows you to define exactly what data AI models can access, from simple queries to complex operations across your entire graph.
- **Declarative operation definition**: Create purpose-built `.graphql` files with operations tailored specifically for AI consumption. These function as persisted operations (trusted documents), giving you complete control over what queries AI models can execute.
- **Flexible data exposure**: Control exactly which operations and fields are exposed to AI systems with granular precision.
- **Compositional API design**: Build different operation sets for different AI use cases without changing your underlying API.
- **Runtime safety**: GraphQL's strong typing ensures AI models can only request valid data patterns that match your schema.
- **Built-in validation**: Operation validation prevents malformed queries from ever reaching your backend systems.
- **Evolve without breaking**: Change your underlying data model while maintaining stable AI-facing operations.
- **Federation-ready**: Works seamlessly with federated GraphQL schemas, giving AI access to data across your entire organization.

But what does this mean in practice? How do these technical benefits translate to real-world solutions? To truly understand the transformative power of GraphQL with MCP, let's explore a common scenario that organizations face when integrating AI with their existing systems.

## The GraphQL Advantage: Real Security for AI Integration

When a major financial services company integrated AI assistants into their customer support workflow, they faced a critical challenge: how could they let AI access transaction data without exposing sensitive financial information or risking regulatory non-compliance?

<Info>Without proper data boundaries, AI models might inadvertently access or expose sensitive customer information, creating security and compliance risks.</Info>

The stakes were high - a single data breach could cost millions in damages and regulatory fines. Their initial attempts using traditional REST APIs led to three significant problems:

1. **Security vulnerabilities**: Their existing REST endpoints contained mixed sensitive and non-sensitive data, making them unusable for AI integration without major restructuring.

2. **Development bottlenecks**: Their engineering team estimated 6+ months to create and maintain a parallel "AI-safe" REST API, delaying their AI initiative significantly.

3. **Data governance issues**: Without granular control, they couldn't meet regulatory requirements for tracking and limiting what data AI systems could access.

**The GraphQL + MCP solution changed everything.**

Instead of rebuilding their API infrastructure, they defined specific GraphQL operations that precisely controlled what data the AI could see:

```graphql
# AI-safe transaction query with PII and financial details removed
query GetTransactionHistory($accountId: ID!, $last: Int!) {
  account(id: $accountId) {
    transactions(last: $last) {
      id
      date
      merchantNameMasked
      category
      amount
      status
      # No account numbers, routing information, location data, or full merchant details
    }
  }
}
```

This approach delivered immediate, tangible benefits:

- **Compliance approval in weeks, not months**: Their compliance team could clearly verify exactly what data AI systems could access, accelerating approval.

- **95% reduction in security review time**: With GraphQL's schema enforcement, security teams had confidence that AI systems couldn't accidentally access unauthorized data.

- **Zero API duplication**: They maintained a single source of truth in their API layer while creating different "views" for different consumers.

- **Future-proof integration**: As they added new data fields to their internal models, those fields remained invisible to AI until explicitly added to AI-accessible operations.

When customers ask questions like "Did my payment to Amazon go through?", the AI assistant can provide helpful answers by querying only transaction status and basic details - without ever seeing full account numbers, balance information, or other sensitive data.

Meanwhile, the same underlying API serves their web and mobile applications with complete data access where appropriate.

This level of surgical precision in data exposure is what makes GraphQL with MCP the gold standard for secure AI integration. No other approach offers this combination of security, flexibility, and developer productivity.

## How It Works

The Cosmo Router server:

1. Loads GraphQL operations from a specified directory
2. Validates them against your schema
3. Generates JSON schemas for operation variables
4. Exposes these operations as tools that AI models can discover and use
5. Handles execution of operations when called by AI models

When an AI model interacts with your MCP endpoint:

1. It discovers available GraphQL operations
2. Understands input requirements through the JSON schema
3. Executes operations with appropriate parameters
4. Receives structured data that it can interpret and use in its responses

## Built-in MCP Tools

The MCP server provides several tools out of the box to help AI models discover and interact with your GraphQL API:

### Discovery Tools

<CardGroup cols={2}>
  <Card title="list_operations" icon="list">
    Lists all available GraphQL operations with their names, descriptions, and operation types. This is typically the first tool AI models use to discover what capabilities your API offers.
  </Card>
  <Card title="get_operation_info" icon="circle-info">
    Retrieves detailed information about a specific GraphQL operation, including its input schema, query structure, and execution guidance. AI models use this to understand how to properly call an operation.
  </Card>
  <Card title="get_schema" icon="code">
    Provides the full GraphQL schema as a string. This helps AI models understand the entire API structure. This tool is only available if `expose_schema` is enabled.
  </Card>
</CardGroup>

### Execution Tools

<CardGroup cols={2}>
  <Card title="execute" icon="play">
    Executes arbitrary GraphQL queries or mutations against your API. This tool is only available if `enable_arbitrary_operations` is enabled, allowing AI models to craft and execute custom operations beyond predefined ones.
  </Card>
  <Card title="execute_*" icon="rocket">
    For each GraphQL operation in your operations directory, the MCP server automatically generates a corresponding execution tool with the pattern `execute_<operation_name>` (e.g., `execute_get_users`).
  </Card>
</CardGroup>

The operation execution tools provide a structured and controlled way for AI models to interact with your API:

- **Tool naming**: Tools follow the pattern `execute_<operation_name>` (with operation names converted to snake_case)
- **Tool schema**: Generated from your GraphQL operation's variables, ensuring type safety
- **Tool description**: Inherited from your GraphQL operation descriptions, including operation name and additional context
- **Mutation warnings**: Tools for mutation operations include a warning that the operation has side effects

By default, all operations in your specified directory will be exposed as tools. Use the `exclude_mutations: true` configuration option to prevent mutation operations from being exposed if you want to ensure AI models can only read data.

## Configuration

To enable MCP in your Cosmo Router, add the following configuration to your `config.yaml`:

```yaml
mcp:
  enabled: true
  server:
    port: "5025"
  storage:
    provider_id: "operations-fs"  # References a file_system provider defined below
  graph_name: "my-graph"
  exclude_mutations: true
  enable_arbitrary_operations: false
  expose_schema: false

# Configure storage providers
storage_providers:
  file_system:
    - id: "operations-fs"
      path: "/path/to/operations"
```

### Configuration Options

| Option | Description | Default |
|--------|-------------|---------|
| `enabled` | Enable or disable the MCP server | `false` |
| `server.port` | The port where the MCP server will listen for requests | `5025` |
| `storage.provider_id` | The ID of a storage provider to use for loading GraphQL operations. Only file_system providers are supported. | - |
| `graph_name` | The name of the graph to be used by the MCP server | `cosmo` |
| `exclude_mutations` | Whether to exclude mutation operations from being exposed | `false` |
| `enable_arbitrary_operations` | Whether to allow arbitrary GraphQL operations to be executed. <Warning>Security risk: Should only be enabled in secure, internal environments.</Warning> | `false` |
| `expose_schema` | Whether to expose the full GraphQL schema. <Warning>Security risk: Should only be enabled in secure, internal environments.</Warning> | `false` |

## Storage Providers

MCP loads operations from a configured file system storage provider. This allows you to centralize the configuration of operation sources:

```yaml
storage_providers:
  file_system:
    - id: "operations-fs"
      path: "/path/to/operations"
```

Then reference this storage provider in your MCP configuration:

```yaml
mcp:
  storage:
    provider_id: "operations-fs"
```

A storage provider must be specified to load GraphQL operations.

## Setting Up Operations

1. Create a directory to store your GraphQL operations as specified in your `storage.provider_id` configuration.
2. Add `.graphql` files containing named GraphQL operations.

Each operation file should contain a single named operation along with a description comment that AI models can use to understand its purpose.

### Example Query Operation

Create a file `operations/getUsers.graphql`:

```graphql
# Returns a list of all users in the system with their basic information
# This is a read-only operation that doesn't modify any data
query GetUsers {
  users {
    id
    name
    email
  }
}
```

### Example Mutation Operation

Create a file `operations/createUser.graphql`:

```graphql
# Creates a new user in the system
# Required inputs: name and email
mutation CreateUser($name: String!, $email: String!) {
  createUser(input: { name: $name, email: $email }) {
    id
    name
    email
  }
}
```

### Directory Structure

Here's an example of how your project directory might be structured:

```
my-router-project/
├── config.yaml                 # Router configuration file
├── operations/                 # Operations directory (as configured in storage provider)
│   ├── getUsers.graphql        # Query operation
│   ├── createUser.graphql      # Mutation operation
│   ├── getUserById.graphql     # Query with parameters
└── ...
```

The important points:
- The path in your `storage_providers.file_system.path` should point to the operations directory
- All `.graphql` files in this directory (and subdirectories) will be loaded
- Each file should contain a single named GraphQL operation

### Operation Naming and Tool Generation

The MCP server converts each operation into a corresponding tool:

- Operation name: `GetUsers` → Tool name: `execute_get_users`
- Operation name: `CreateUser` → Tool name: `execute_create_user`

Operations are converted to snake_case for tool naming consistency.

### Best Practices

1. **Meaningful names**: Give operations clear, action-oriented names that describe what they do.
2. **Add descriptions**: Include comments that describe the operation's purpose, required inputs, and any side effects.
3. **Use explicit types**: Define all input variables with explicit types to ensure proper validation.
4. **Create focused operations**: Design operations specifically for AI model consumption rather than exposing generic operations.
5. **Security considerations**: For mutation operations, add checks and validations to prevent misuse.

## Security Considerations

Currently, only public operations are supported by default. Passing authentication headers will be supported soon by Cursor, Claude, and other AI tools. Once supported, users can issue regular tokens to interact with the router as usual through the standard router authentication integration.

## Integration with AI Platforms

The MCP server exposes GraphQL operations in a format compatible with AI platforms that support function calling or tool use. Here's how to configure popular AI platforms to connect to your Cosmo Router's MCP endpoint:

### Claude Desktop App

For Claude desktop app on macOS/Linux:

1. Locate or create the Claude config file:
   ```bash
   code ~/Library/Application\ Support/Claude/claude_desktop_config.json
   ```

2. Add the following configuration:
   ```json
   {
     "mcpServers": {
       "mygraph": {
         "command": "npx",
         "args": [
           "mcp-remote",
           "http://localhost:5025/sse"
         ]
       }
     }
   }
   ```

3. Save the file and restart Claude.

### Cursor IDE

To configure Cursor to connect to your MCP endpoint:

1. Open a chat session with an AI agent in Cursor
2. Click on the three dots (⋮) in the top-right corner of the chat panel
3. Select "Chat Settings"
4. Navigate to the MCP section
5. Click on "Add new global MCP server"
6. Enter the following configuration:
   ```json
   {
     "mcpServers": {
       "mygraph": {
         "url": "http://localhost:5025/sse"
       }
     }
   }
   ```
7. Save the configuration

### Windsurf

To configure Windsurf to connect to your MCP endpoint:

1. Open a chat session with an AI agent in Windsurf
2. Click on the hammer icon with the text "Configure"
3. Use the following template:
   ```json
   {
     "mcpServers": {
       "mygraph": {
         "serverUrl": "http://localhost:5025/sse"
       }
     }
   }
   ```

### Other Compatible Platforms

These platforms also support MCP or similar tool-use capabilities:

- OpenAI's GPT models (via function calling)
- Other LLMs that support similar capabilities

<Info>MCP's JSON schema generation automatically provides AI models with the metadata they need to understand your operations' input requirements and capabilities.</Info>

## Use Cases

- **AI-powered chatbots** that can query your application data
- **Voice assistants** that need to interact with your business logic
- **Autonomous agents** that make decisions based on your application state
- **Data analysis** tools that need to query specific information
- **Content generation** systems that use your data as context

## Future Outlook

The MCP server in Cosmo Router is under active development, with several exciting features on the roadmap:

<Accordion title="Enhanced Security and Control">
  - **Advanced Authentication**: We're working on comprehensive authentication options for the MCP server, including JWT support, API key validation, and integration with existing auth providers. This will allow for fine-grained access control to ensure only authorized AI agents can access your GraphQL operations.

  - **Rate Limiting**: Upcoming rate limiting features will protect your backend systems from excessive requests, with configurable limits based on client identity, operation type, and other factors. This will help prevent abuse and ensure fair resource allocation among different AI clients.

  - **Request Quotas**: Implementation of daily/monthly quotas per client to manage resource allocation for different tiers of AI service access.
</Accordion>

<Accordion title="Observability and Monitoring">
  - **OpenTelemetry Integration**: Native OpenTelemetry support is in development, enabling detailed tracing of AI requests through your entire system. This will provide visibility into how AI agents are interacting with your data and help identify bottlenecks or issues.

  - **Usage Analytics**: Comprehensive analytics dashboard to understand which operations are most frequently used by AI agents, performance metrics, and error rates.

  - **Audit Logging**: Detailed audit logs of all AI interactions for compliance and security review.
</Accordion>

<Accordion title="Enhanced Developer Experience">
  - **Operation Insights**: Tools to help developers understand which operations would be most useful to AI agents based on common user questions and requests.

  - **Schema Visualization**: Visual representations of which parts of your GraphQL schema are exposed to AI systems, making it easier to manage data boundaries.

  - **MCP Explorer**: An interactive UI for testing and debugging MCP operations before exposing them to AI models.
</Accordion>

These upcoming features will further strengthen the MCP server's position as the most robust solution for securely exposing GraphQL operations to AI systems while maintaining full control over your data.

## Conclusion

The MCP integration in Cosmo Router provides a powerful bridge between your GraphQL API and AI models. By enabling AI systems to discover and interact with your data through a familiar and structured interface, you open up new possibilities for AI-enhanced applications without extensive custom development.

<Tip>Start with a small set of read-only operations to test your AI integration before expanding to more complex functionality.</Tip>

With minimal configuration, you can transform your GraphQL API into a rich ecosystem that AI models can navigate and utilize, creating more intelligent and capable AI-powered features for your users. 