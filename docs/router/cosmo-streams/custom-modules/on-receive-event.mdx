---
title: "OnReceiveEvents Handler"
description: "A Cosmo Streams Custom Module, which lets you customize events received from a message broker before being passed to subscribers"
icon: "arrow-left"
---

The `OnReceiveEvents` handler is a custom module hook that allows you to intercept and process events received from 
supported message brokers before they are delivered to GraphQL subscription clients.
This handler is called whenever a batch of events is received from a message broker, giving you the opportunity to filter, transform, enrich, 
or validate events before they reach your subscribers.

This handler is particularly useful for:
- **Event filtering**: Remove unwanted events based on custom logic
- **Data transformation**: Modify event payloads to match client expectations
- **Event enrichment**: Add additional data to events from external sources
- **Authentication and authorization**: Filter events based on user permissions
- **Monitoring and analytics**: Log or track events for observability

<Info>
If there is no active subscription this handler is not executed, even if new messages arrive at the broker.
This is because the Router will not listen for messages on the broker topic/queue until at least one
client subscribes to a particular subscription.
</Info>

## Handler Interface

In order to use the `OnReceiveEvents` handler you need to create a [Custom Module](../../custom-modules) which implements
the `StreamReceiveEventHandler` interface.

```go
type StreamReceiveEventHandler interface {
    // OnReceiveEvents is called whenever a batch of events is received from a provider,
    // before delivering them to clients.
    // The hook will be called once for each active subscription, therefore it is advised to
    // avoid resource heavy computation or blocking tasks whenever possible.
    // The events argument contains all events from a batch and is shared between
    // all active subscribers of these events.
    // Use events.All() to iterate through them and event.Clone() to create mutable copies, when needed.
    // Returning an error will result in the subscription being closed and the error being logged.
    OnReceiveEvents(ctx StreamReceiveEventHandlerContext, events datasource.StreamEvents) (datasource.StreamEvents, error)
}

type StreamReceiveEventHandlerContext interface {
    // Context is a context for handlers.
	// If it is cancelled, the handler should stop processing.
	Context() context.Context
    // Request is the initial client request that started the subscription
    Request() *http.Request
    // Logger is the logger for the request
    Logger() *zap.Logger
    // Operation is the GraphQL operation
    Operation() OperationContext
    // Authentication is the authentication for the request
    Authentication() authentication.Authentication
    // SubscriptionEventConfiguration the subscription event configuration
    SubscriptionEventConfiguration() datasource.SubscriptionEventConfiguration
    // NewEvent creates a new event that can be used in the subscription.
    NewEvent(data []byte) datasource.MutableStreamEvent
}
```

## Asynchronous Execution and Performance Considerations

The `OnReceiveEvents` handler is executed **asynchronously** for each active subscription when events are received from the message broker.
To control resource usage and prevent overwhelming your system, you can configure the maximum number of concurrent handlers using
the `max_concurrent_handlers` configuration option.

```yaml
events:
  subscription_hooks:
    on_receive_events:
      max_concurrent_handlers: 100  # Default: 100
```

This amount of concurrent handlers is not global inside the router. It is defined per topic / message queue being observed by the router.
If you define multiple Cosmo Streams subscriptions inside your schema, each one will have its own concurrent handlers limit.

When the maximum number of concurrent handlers is reached for a topic, events will not get polled from the message queue until a handler has finished its work and is free again.
To avoid sending out of order events to the subscription clients, the router will wait a certain amount of time for all handlers to finish, before polling the next batch of events.
This timeout is configurable via router configuration:
```yaml
events:
    subscription_hooks:
      on_receive_events:
        handler_timeout: 1s # default: 5s
```

If the timeout is reached, the router will poll the next batch of events immediately, which could result in sending out of order events to the subscription clients.
In this case a warning will be logged.

We recommend to use the `ctx.Context()`, which is cancelled in such a case.
You can use it to abort any long running operations:

```go
func (m *CosmoStreamsModule) OnReceiveEvents(
    ctx core.StreamReceiveEventHandlerContext,
    events datasource.StreamEvents,
) (datasource.StreamEvents, error) {
	for _, event := range events.All() {
		select {
		case <-ctx.Context().Done():
			ctx.Logger().Debug("context cancelled, stopping processing and return no events to subscriber")
			return datasource.StreamEvents{}, nil
		default:
			// process event here...
		}
	}
	return events, nil
}
```

<Info>
The router will not abort the handler if the context is cancelled. It will simply move on to receive the next batch of events from the broker and process them.
In this case events could be sent out of order to subscription clients, because old long-running handlers are still processing the previous batch of events.
</Info>

<Warning>
For as long as the handler limit is reached, the router will not poll the next batch of events from the broker.
This effectively means that the subscription does not get updated until a new handler is free again.
</Warning>

## Error Handling

When the `OnReceiveEvents` handler returns an error, the router takes the following actions:

1. **Send Returned Events**: Alongside the error you can return events, if you wish to sent them to the client prior connection closing
2. **Subscription Closure**: The affected subscription is immediately closed for the client that encountered the error
3. **Error Logging**: The error is logged by the router with details about the subscription, provider, and field name
4. **Error Deduplication**: If multiple subscriptions experience the same error for the same events, the router deduplicates the error messages in the logs to prevent spam
5. **No Error Propagation**: The error is **not** sent directly to the GraphQL client - the subscription simply closes

<Warning>
Returning an error from `OnReceiveEvents` will close the subscription for that specific client. Use this only when you want to terminate the subscription due to unrecoverable conditions. For filtering events, return an empty event list instead of an error.
</Warning>

<Note>
The error gets logged by the router but it won't be send to the client.
From the view of the client the subscription closes server-side without a reason. We are working on a solution for this.
</Note>

**Example of proper error handling:**

```go
func (m *MyEventHandler) OnReceiveEvents(
    ctx core.StreamReceiveEventHandlerContext, 
    events datasource.StreamEvents,
) (datasource.StreamEvents, error) {
    // For recoverable issues, filter events instead of returning errors
    if someCondition {
        return datasource.NewStreamEvents(nil), nil // Empty events, no error
    }
    
    // Only return errors for unrecoverable conditions
    if criticalSystemFailure {
        return nil, errors.New("critical system failure - closing subscription")
    }
    
    return events, nil
}
```

## Usage Example

### Complete Custom Module with Event Bypass

The following example contains a complete Custom Module implementation, including handler registration,
with a handler that will simply bypass events unchanged. This is not useful on it's own but demonstrates
how to register your `OnReceiveEvents` Custom Module.

```go
package module

import (
    "github.com/wundergraph/cosmo/router/core"
    "github.com/wundergraph/cosmo/router/pkg/pubsub/datasource"
    "go.uber.org/zap"
)

func init() {
    // Register your module with the router
    core.RegisterModule(&EventBypassModule{})
}

const ModuleID = "eventBypassModule"

// EventBypassModule demonstrates a complete custom module implementation
// that implements StreamReceiveEventHandler but simply passes events through unchanged
type EventBypassModule struct {}

// OnReceiveEvents passes all events through unchanged
func (m *EventBypassModule) OnReceiveEvents(
    ctx core.StreamReceiveEventHandlerContext, 
    events datasource.StreamEvents,
) (datasource.StreamEvents, error) {
    logger := ctx.Logger()
    logger.Debug("Processing events - bypassing unchanged", 
        zap.Int("event_count", len(events.All())),
    )
    
    // Simply return the events unchanged
    return events, nil
}

// Module returns the module information for registration
func (m *EventBypassModule) Module() core.ModuleInfo {
    return core.ModuleInfo{
        ID: ModuleID,
        New: func() core.Module {
            return &EventBypassModule{}
        },
    }
}

// Interface guards to ensure we implement the required interfaces
var (
    _ core.StreamReceiveEventHandler = (*EventBypassModule)(nil)
)
```

### Restrict Handler to run on certain subscriptions and providers

Most of the time you want your hook to only deal with a certain subscription.  
The `OnReceiveEvents` Handler is run for every subscription configured for Cosmo Streams.
You can access the name of the subscription you care for and return early if it's not the right one.

```go
func (m *SelectiveEventHandler) OnReceiveEvents(
    ctx core.StreamReceiveEventHandlerContext, 
    events datasource.StreamEvents,
) (datasource.StreamEvents, error) {
    logger := ctx.Logger()
    subConfig := ctx.SubscriptionEventConfiguration()

    // Bypass handler if it's not the right subscription
    if subConfig.RootFieldName() != "employeeUpdated" {
        return events, nil
    }

    // And / or you can decide to process events only from a specific provider configured in the Router
    if subConfig.ProviderID() != "my-nats" {
        return events, nil
    }
    

    // Your specific event processing logic here
    // ...
    
    return datasource.NewStreamEvents(processedEvents), nil
}
```

### Filter out events based on clients authentication token claim

You can use `ctx.Authentication()` to access authentication data, such as tokens, if available.
Based on that you can filter events, if the token misses the proper claim.

```go
func (m *EventFilterModule) OnReceiveEvents(
    ctx core.StreamReceiveEventHandlerContext, 
    events datasource.StreamEvents,
) (datasource.StreamEvents, error) {
    logger := ctx.Logger()
    auth := ctx.Authentication()
    
    // If no authentication, block all events
    if auth == nil {
        return datasource.NewStreamEvents(nil),
            errors.New("No authentication present, closing subscription")
    }
    
    // Check JWT claims
    claims := auth.Claims()
    if claims == nil {
        return datasource.NewStreamEvents(nil),
            errors.New("No claims present, closing subscription")
    }
    
    // Check for admin role claim
    roleClaimValue, hasRole := claims["role"]
    if !hasRole {
        logger.Debug("No role claim, blocking all events")
        return datasource.NewStreamEvents(nil), nil
    }
    
    userRole, ok := roleClaimValue.(string)
    if !ok || userRole != "admin" {
        logger.Debug("User is not admin, blocking all events", 
            zap.Any("role", roleClaimValue),
        )
        return datasource.NewStreamEvents(nil), nil
    }
    
    // User is admin - pass all events through
    logger.Debug("Admin user authorized, passing all events", 
        zap.Int("event_count", events.Len()),
    )
    return events, nil
}
```

### Filter out events based on message metadata

Certain providers enrich their messages with metadata accessible by the Router.
Kafka and NATS, for example, have the option to add headers to messages.
Here's an example that filters out all messages coming from a Kafka broker where a header indicates
it's not meant for GraphQL subscriptions.

```go
import (
    "github.com/wundergraph/cosmo/router/pkg/pubsub/kafka"
)

func (m *HeaderFilterModule) OnReceiveEvents(
    ctx core.StreamReceiveEventHandlerContext, 
    events datasource.StreamEvents,
) (datasource.StreamEvents, error) {
    logger := ctx.Logger()
    
    // Only process events from Kafka providers.
    // Pass through unchanged for non-Kafka providers.
    if ctx.SubscriptionEventConfiguration().ProviderType() != datasource.ProviderTypeKafka {
        return events, nil
    }
    
    // Optionally validate specific provider ID or subscription field
    logger.Debug("Processing Kafka events for subscription",
        zap.String("provider_id", subConfig.ProviderID()),
        zap.String("field_name", subConfig.RootFieldName()),
        zap.Int("event_count", events.Len()),
    )
    
    filteredEvents := make([]datasource.StreamEvent, 0, events.Len())
    
    for _, event := range events.All() {
        // Check if this is a Kafka event with headers
        if kafkaEvent, ok := event.(*kafka.Event); ok {
            headers := kafkaEvent.GetHeaders()
            
            // Filter out events with "internal" header set to "true"
            if internalHeader, exists := headers["internal"]; exists {
                if string(internalHeader) == "true" {
                    logger.Debug("Filtering out internal event")
                    continue
                }
            }
        }
        
        // Include this event in the results
        filteredEvents = append(filteredEvents, event)
    }
    
    logger.Debug("Filtered events by headers",
        zap.Int("original_count", events.Len()),
        zap.Int("filtered_count", len(filteredEvents)),
    )
    
    return datasource.NewStreamEvents(filteredEvents), nil
}
```