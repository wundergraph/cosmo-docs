---
title: "gRPC Services"
description: "Integrate external gRPC services into your GraphQL Federation Supergraph."
icon: server
---

## Introduction

The Cosmo Router supports integration with external gRPC services through a schema-first approach. You define a GraphQL schema that represents the interface to your gRPC services, and the Cosmo tooling generates the corresponding Protocol Buffer definitions and mappings that enable the router to establish a connection.

This approach allows you to bridge any service - whether it's gRPC, REST, SOAP, or legacy systems - into your GraphQL Federation Supergraph by creating a protocol translation layer. The router handles the communication with your remote services based on the generated mappings, making it easy to modernize your architecture while preserving existing investments.

## What are gRPC Services in Cosmo?

gRPC services in Cosmo are external microservices that you integrate into your GraphQL Federation through a code generation workflow:

- **Schema-driven integration** where you define GraphQL schemas that represent your gRPC service interfaces
- **Automatic protobuf generation** from your GraphQL schema definitions
- **Router-managed communication** where the Cosmo Router handles calls to external gRPC services
- **Protocol translation** between GraphQL requests and gRPC calls
- **Type-safe mappings** ensuring consistency between GraphQL and protobuf definitions
- **External service autonomy** where your gRPC services remain independent and unchanged

The workflow involves:
- **Define GraphQL schema** that represents your gRPC service interface
- **Generate protobuf definitions** from the GraphQL schema
- **Implement your gRPC service** in your preferred language
- **Configure service mappings** that tell the router how to call your gRPC services
- **Deploy and connect** the router to your external gRPC services

## Workflow

<Steps>
  <Step title="Define GraphQL Schema">
    Create a GraphQL schema that represents the interface to your gRPC service. This schema defines the types, queries, mutations, and inputs that will be exposed through your GraphQL API.
  </Step>
  <Step title="Generate Protobuf Files">
    Use the Cosmo CLI to automatically generate protobuf service definitions and mapping configurations from your GraphQL schema. This creates the bridge between GraphQL and gRPC protocols.
  </Step>
  <Step title="Implement gRPC Service">
    Build your gRPC service in your preferred programming language using the generated protobuf definitions. The service implements the business logic for your GraphQL operations.
  </Step>
  <Step title="Configure Router">
    Create a compose configuration file that tells the Cosmo Router how to connect to your gRPC service and generate the final router configuration.
  </Step>
  <Step title="Deploy and Test">
    Start your gRPC service and the Cosmo Router, then test the integration by making GraphQL queries that are translated to gRPC calls.
  </Step>
</Steps>

## Why Use gRPC Services in GraphQL Federation?

For a comprehensive overview of the benefits of bridging external services into your GraphQL Federation, see our [gRPC Plugins documentation](/router/plugins), which covers the core advantages of this approach.

gRPC services offer the same foundational benefits as gRPC plugins but with key architectural differences that make them suitable for different deployment scenarios.

## Key Differences from gRPC Plugins

<CardGroup cols={2}>
    <Card title="Remote Deployment" icon="cloud">
        Unlike plugins that run as locally forked processes managed by the router, gRPC services can be deployed anywhere in your infrastructure - different servers, containers, or even cloud regions.
    </Card>
    
    <Card title="Language Agnostic" icon="globe">
        While gRPC plugins currently only support Go, gRPC services can be implemented in any language that supports gRPC - Python, Java, C#, Node.js, Rust, and many others.
    </Card>
    
    <Card title="Independent Scaling" icon="arrows-split-up-and-left">
        Services can be scaled independently based on their specific load patterns and resource requirements, without affecting the router or other services.
    </Card>
    
    <Card title="Network Communication" icon="network-wired">
        Communication happens over the network using standard gRPC protocols, enabling distributed architectures and cross-datacenter deployments.
    </Card>
    
    <Card title="Service Autonomy" icon="building">
        Each service maintains its own deployment lifecycle, monitoring, and operational concerns, following traditional microservices patterns.
    </Card>
    
    <Card title="Team Independence" icon="users">
        Different teams can own and operate their services independently, using their preferred languages, frameworks, and deployment strategies.
    </Card>
</CardGroup>

## When to Choose gRPC Services vs Plugins

**Choose gRPC Services when:**
- <Icon icon="globe" /> You need to use languages other than Go 
- <Icon icon="users" /> Services are owned by different teams
- <Icon icon="arrows-split-up-and-left" /> You require independent scaling and deployment
- <Icon icon="network-wired" /> Services are distributed across different environments

**Choose gRPC Plugins when:**
- <Icon icon="rocket" /> You want the simplest possible deployment model
- <Icon icon="bolt" /> Performance is critical (lower latency with local communication)
- <Icon icon="laptop-code" /> You're comfortable with Go development
- <Icon icon="arrows-rotate" /> You prefer unified deployment and monitoring

## Benefits Over Traditional REST Integration

When compared to integrating REST APIs into GraphQL Federation, the gRPC service approach offers several advantages:

<CardGroup cols={1}>
    <Card title="Efficient Communication" icon="bolt">
        Binary protocol and HTTP/2 multiplexing provide better performance than traditional REST over HTTP/1.1, especially for high-frequency service-to-service communication.
    </Card>
    <Card title="Automatic Code Generation" icon="wand-magic-sparkles">
        Generate protobuf definitions and service mappings directly from your GraphQL schema, reducing development time and ensuring consistency between schema and implementation.
    </Card>
    <Card title="Contract-First Development" icon="file-contract">
        GraphQL schemas serve as the single source of truth for service contracts, with protobuf definitions generated automatically to ensure compatibility.
    </Card>
</CardGroup>

## Architecture Overview

The integration of gRPC services into GraphQL Federation follows this pattern:

1. **Schema Definition**: You define GraphQL schemas that represent the interface to your gRPC services
2. **Code Generation**: Cosmo tooling generates protobuf definitions and service mappings from your GraphQL schemas
3. **Router Configuration**: The router is configured with the generated mappings to understand how to call your gRPC services
4. **Request Processing**: When GraphQL queries are received, the router translates relevant portions into gRPC calls
5. **Protocol Translation**: The router handles the translation between GraphQL and gRPC protocols
6. **Response Assembly**: Results from gRPC service calls are translated back to GraphQL and assembled into the final response

This architecture enables you to maintain your existing gRPC services unchanged while providing a unified GraphQL interface to your clients.

## Next Steps

- [Quickstart](/router/grpc-services/quickstart)