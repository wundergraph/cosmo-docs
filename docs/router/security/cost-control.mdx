---
title: "Cost Analysis"
description: "Protect the API from expensive operations by estimating query complexity before execution using @cost and @listSize directives"
icon: scale-balanced
---

## Overview

Some GraphQL queries are more expensive than others. A query requesting deeply nested lists can generate
thousands of resolver calls and overwhelm subgraphs, while a simple field lookup costs almost nothing.
Cost analysis allows assigning weights to fields and estimating query complexity *before* execution begins.

When cost analysis is enabled, the router calculates an estimated cost for each incoming operation based
on the fields requested, their configured weights, and expected list sizes.
Operations exceeding the configured limit are rejected immediately — no subgraph requests are made,
protecting the infrastructure from resource exhaustion.

This feature implements the [IBM GraphQL Cost Directive Specification](https://ibm.github.io/graphql-specs/cost-spec.html),
adapted for GraphQL Federation.

### Key differences from the IBM specification

Specification does not take into account the federation aspect. Some implementation details to
explain how we calculate static costs. Static cost value is based on the query plan. Query plan
use a federation of subgraphs to create a chain of fetches. This chain of fetches is invisible
(on the supergraph level) and could happen because of entity calls, `@requires` fetches, etc.
We account for those because they all make some type of queries more expensive.

We do not use stringified floats for weights but rather plan integer values.

Router supports calculation of static (estimated) costs only at this moment.
Dynamic (runtime) cost calculated on the actual data returned from the subgraphs, is in active
development.

## How Cost is Calculated

The router walks through the query and sums up the cost of each field. This is a simplified abstraction,
but this should be used as a basis to estimate how expensive queries are.

By default, object types (including interfaces and unions) cost `1`, scalar and enum fields cost `0`.
For example, this query has a cost of `4`:

```graphql
query {
  book(id: 1) {          # Book object: 1
    title                 # String scalar: 0
    author {              # Author object: 1
      name                # String scalar: 0
    }
    publisher {           # Publisher object: 1
      address {           # Address object: 1
        zipCode           # Int scalar: 0
      }
    }
  }
}
```
In reality, router takes into account the possible weights assigned to the same field coordinate
in different subgraphs.
It is possible to make particular field resolvers on particular subgraphs more expensive.

### List Fields Multiply Cost

When a field returns a list, the cost of that field and all its children is multiplied by the expected list size.
Since the router doesn't know actual list sizes at planning time, it uses estimates.

```graphql
query {
  employees {            # List of Employee
    id
    department {
      name
    }
  }
}
```

With a default list size of 10, this query costs: `10 × (1 Employee + 1 Department) = 20`

## Configuration

Cost analysis is enabled in the router configuration:

```yaml
security:
  cost_analysis:
    enabled: true
    static_limit: 1000
    list_size: 10
```

| Option         | Environment Variable                  | Description                                                                                                                                               |
|----------------|---------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------|
| `enabled`      | `SECURITY_COST_ANALYSIS_ENABLED`      | When true, the router calculates static cost for every operation. Required to use to access cost from custom modules.                                     |
| `static_limit` | `SECURITY_COST_ANALYSIS_STATIC_LIMIT` | Maximum allowed cost. Operations exceeding this limit receive a 400 error. Set to 0 to calculate costs without enforcing a limit (useful for monitoring). |
| `list_size`    | `SECURITY_COST_ANALYSIS_LIST_SIZE`    | Default assumed size for list fields when no `@listSize` directive is specified. Should reflect typical list sizes in the API.                            |

## Customizing Cost with Directives

Default weights work for many APIs,
but cost calculation can be fine-tuned using the `@cost` and `@listSize` directives in the schema.

### The @cost Directive

`@cost` assigns custom weights to types, fields or arguments that are more expensive than average.

When specified **on a type** — all fields returning this type inherit the weight:

```graphql
type Address @cost(weight: 5) {
  street: String
  city: String
  zipCode: String
}
```

When specified **on a field** — only specific field has this weight:

```graphql
type Query {
  search(term: String!): [Result] @cost(weight: 10)
}
```

When specified **on an argument** — add cost for expensive argument processing:

```graphql
type Query {
  users(filter: UserFilter @cost(weight: 3)): [User]
}
```

### The @listSize Directive

`@listSize` provides better list size estimates than the global default.

**Static size with `assumedSize`** — when a field always returns roughly the same number of items:

```graphql
type Query {
  topProducts: [Product] @listSize(assumedSize: 5)
  featuredCategories: [Category] @listSize(assumedSize: 3)
}
```

**Dynamic size with `slicingArguments`** — when the list size is controlled by a pagination argument:

```graphql
type Query {
  products(first: Int, after: String): ProductConnection 
    @listSize(slicingArguments: ["first"])
  
  searchResults(limit: Int!, offset: Int): [Result]
    @listSize(slicingArguments: ["limit"])
}
```

The router reads the argument value from the query to determine the multiplier:

```graphql
query {
  products(first: 20) {   # Multiplier is 20
    edges { node { name } }
  }
}
```

When multiple slicing arguments are provided, the router uses the maximum value among them.

## Accessing Cost in Custom Modules

In custom modules, the calculated cost is accessible through the operation context:

```go
func (m *MyModule) Middleware(ctx core.RequestContext, next http.Handler) {
    // Get the static cost after planning
    cost, err := ctx.Operation().StaticCost()
    if err != nil {
        // Cost analysis not enabled or plan not ready
    }
    
    // Use cost for custom logic (rate limiting, logging, etc.)
    if cost > m.warningThreshold {
        m.logger.Warn("High cost operation", "cost", cost)
    }
    
    next.ServeHTTP(ctx.ResponseWriter(), ctx.Request())
}
```

This enables use cases like:

- Custom rate limiting based on query cost
- Logging expensive operations for analysis
- Billing based on query complexity
- Dynamic throttling during high-load peaks

## Error Responses

When a query exceeds the static limit, the router returns a 400 status with an error:

```json
{
  "errors": [
    {
      "message": "The estimated query cost 1540 exceeds the maximum allowed static cost 1500"
    }
  ]
}
```

## Best Practices

### Start with Monitoring

Start with `static_limit: 0` to calculate costs without rejecting any queries.
This allows traffic patterns to be understood before setting limits.

```yaml
security:
  cost_analysis:
    enabled: true
    static_limit: 0  # Monitor only
    list_size: 10
```

### Pick Parameters for @list_size Carefully

The default list size significantly impacts cost calculations.
If lists typically return 5–20 items, a default of 10 is reasonable.
For fields that return large lists (100+ items), consider:

1. Using `@listSize(assumedSize: N)` on those specific fields
2. Requiring pagination with `slicingArguments`

### Annotate Expensive Resolvers

`@cost` should be applied to fields that trigger expensive operations:

- External API calls
- Complex computations
- Large database queries
- Fields that fan out to multiple subgraphs

```graphql
type Query {
  # Calls external payment API
  paymentHistory(userId: ID!): [Payment] @cost(weight: 5)
  
  # Requires joining multiple tables
  analyticsReport(dateRange: DateRange!): Report @cost(weight: 10)
}
```

### Design for Pagination

APIs with pagination provide better cost estimation.
`slicingArguments` gives the router accurate multipliers based on what clients actually request:

```graphql
type Query {
  # Good: cost scales with requested page size
  users(first: Int!, after: String): UserConnection
    @listSize(slicingArguments: ["first"])
  
  # Less ideal: cost uses default list_size
  allUsers: [User]
}
```

### Nested Lists

Nested list fields require special attention, as costs multiply:

```graphql
query {
  departments {           # 10 departments
    employees {           # × 10 employees each = 100
      projects {          # × 10 projects each = 1000
        tasks {           # × 10 tasks each = 10000
          name
        }
      }
    }
  }
}
```

With default list size of 10, this query has a cost of over 10,000.
`@listSize` should be used to provide realistic estimates for deeply nested structures.

## Features Not Yet Implemented

- **Runtime or dynamic cost measurement** after execution based on actual list sizes returned by subgraphs
- **Cost telemetry** — OTEL metrics and span attributes for cost values (`cost.estimated`, `cost.actual`, `cost.delta`)
- `sizedFields` in @listSize for applying list size estimates to specific child fields rather than all children
- `requireOneSlicingArgument` for validation of queries
- **Input object fields** when used as parameters of fields
- **Arguments of directives** are not accounted for weights

