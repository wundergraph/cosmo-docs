---
title: "Configuration Design"
description: "Designing and structuring configuration files"
icon: "ruler-combined"
---

## Config Design Overview

This section gives you an overview of how the router handles configuration merging and provides guidance on how you can structure your configurations effectively.

### Configuration Merging

The router lets you load multiple configurations at once. You can specify your configurations in two ways:

1. Using the `CONFIG_PATH` environment variable or in your `.env` file:
```bash
CONFIG_PATH=base.config.yaml,dev.config.yaml
```

2. Using the `config` flag when starting the router:
```bash
# Pass params individually
./router --config base.config.yaml --config dev.config.yaml

# Or pass them as a comma separated list
./router --config base.config.yaml,dev.config.yaml
```

### Environment Variables

We load environment variables first, before applying the values from your YAML configurations. This means that any values you set in environment variables can be overridden by your YAML configurations if needed.

You have two options for environment files:
- A base `.env` file for your common settings
- An override environment file using `OVERRIDE_ENV` for environment-specific settings

The values from your `OVERRIDE_ENV` file will take precedence over the base `.env` file (if you have one).

#### How Merging Works

Before we merge your configurations, we validate each YAML file against our [configuration schema](/router/configuration#config-validation-%26-auto-completion). This ensures everything is valid before we start combining them.

Here's how the merging process works:
- The last configuration in your list has the highest priority
- If a key exists in multiple files, the last one wins
- New keys get added if they don't exist yet
- After merging, we validate everything again to make sure all rules are followed

Let's look at a simple example to see how this works:

**base.yaml**
```yaml
listen_addr: 127.0.0.1:3007
poll_interval: 17s
```

**dev.yaml**
```yaml
listen_addr: listen.address:3007
readiness_check_path: /health/ready/check
```

The final output will be:
```yaml
listen_addr: listen.address:3007
poll_interval: 17s
readiness_check_path: /health/ready/check
```

As you can see, `listen_addr` from dev.yaml overrode the one from base.yaml, while `poll_interval` carried forward since it wasn't overridden.

If we add another file after **dev.yaml**:
```yaml
listen_addr: new.address:3007
readiness_check_path: /health/ready/check
```

The final output becomes:
```yaml
listen_addr: new.address:3007
poll_interval: 17s
readiness_check_path: /health/ready/check
```

> **Important Note**: When dealing with lists in your YAML configurations, the entire list gets replaced rather than merged. This is especially important to remember when your list elements have a `key` attribute.

Here's an example to show what we mean:

**base.yaml**
```yaml
telemetry:
  attributes:
    - key: content_type
      default: 'no-content-type-found'
      value_from:
        request_header: content-type
```

**dev.yaml**
```yaml
listen_addr: 127.0.0.1:3007
telemetry:
  attributes:
    - key: operation_sha
      default: 'no_sha'
      value_from:
        context_field: operation_sha256
    - key: operation_validation_time
      default: 'no_validation_time'
      value_from:
        context_field: operation_validation_time
```

The final output will be:
```yaml
listen_addr: 127.0.0.1:3007
telemetry:
  attributes:
    - key: operation_sha
      default: 'no_sha'
      value_from:
        context_field: operation_sha256
    - key: operation_validation_time
      default: 'no_validation_time'
      value_from:
        context_field: operation_validation_time
```

### Hot Config Reloading

When you enable [hot config reloading](/router/configuration#config-watcher-hot-reloading), we'll watch all your configuration files for changes. Whenever any configuration changes, we'll reprocess everything and rebuild your final merged configuration.

## Designing Configurations

Before configuration merging, you had to use one big configuration file, which could get messy and hard to maintain. Now you can split your configurations into smaller, more manageable pieces. Here are some ways you can structure your configurations:

### Environment-Based Structure

This is a common approach where you split your configs by environment:

```
config/
  base.config.yaml
  dev/
    dev.config.yaml
  staging/
    stage.config.yaml
  production/
    prod.config.yaml
```

You can use these environment variables for each environment:
```bash
# for dev
CONFIG_PATH=base.config.yaml,./dev/dev.config.yaml

# for staging
CONFIG_PATH=base.config.yaml,./staging/stage.config.yaml

# for prod
CONFIG_PATH=base.config.yaml,./production/prod.config.yaml
```

### Feature-Based Structure

You can also organize your configs by feature:

```
config/
  rate_limit.yaml
  telemetry.yaml
  prod/
    telemetry.yaml
    tracing.yaml
    metrics.yaml
```

Here's how you might use these configs:
```bash
# for prod
CONFIG_PATH=rate_limit.yaml,telemetry.yaml,./prod/telemetry.yaml,./prod/tracing.yaml,./prod/metrics.yaml
```

> **Note**: When using this approach, be careful not to accidentally duplicate attributes across different files. For example, if you define a rate limiting attribute in both `rate_limit.yaml` and `telemetry.yaml`, the one in `telemetry.yaml` will override the other.

### Combining Configuration and Environment Files

You can even combine both approaches with environment variables:

```
config/
  base.config.yaml
  .env
  dev/
    .env.dev
    dev.config.yaml
  staging/
    .env.stage
    stage.config.yaml
  production/
    .env.prod
    prod.config.yaml
```

For your staging environment, you would set:
```bash
OVERRIDE_ENV=./staging/.env.stage
```

These configuration patterns are suggestions to help you get started. Feel free to adapt them to match your specific requirements and organizational needs. The key is to maintain a structure that makes sense for your team and use case.

