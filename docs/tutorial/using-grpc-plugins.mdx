---
title: "Using Cosmo Cloud gRPC plugins to quickly build and deploy a gRPC subgraph"
description: "Learn how to use gRPC plugins with Cosmo Cloud & Cosmo Router"
icon: plug
---

## Prerequisites

---
---
---
---
---
---
---
---
---
TODO: ADD MINIMUM VERSIONS ON RELEASE
---
---
---
---
---
---
---
---
---
---

- [Cosmo CLI](/cli/intro) installed and configured
- [Cosmo Router](/router/intro) installed and configured to use Cosmo Cloud

## Overview

gRPC plugins are a powerful new way to write and deploy subgraphs without the need for a GraphQL server. You can use plugins to wrap legacy APIs, mock future subgraphs or fully implement new features. Plugins are written in Go and can be deployed and run automatically by the Cosmo Router.

For this tutorial, we'll create a gRPC plugin called `starwars` that wraps a small portion of the REST API from [SWAPI](https://swapi.info/). SWAPI is a free and open-source public API that provides information about Star Wars characters, planets, and more. For the tutorial, it functions as a stand-in for your own API or external datasource (an SQL database, Stripe, etc.).

gRPC plugins support all the same features as [gRPC services](/router/gRPC/grpc-services), but you don't have to create separate deployments, handle networking, or manage inter-service authentication.

Here's a short version of the steps for reference:

<Steps>
  <Step title="Initialize a new plugin">
    Create a new gRPC plugin using `wgc router plugin init <name>` and define your GraphQL schema.
    
    [→ Jump to initialization](#initialize-plugin)
  </Step>
  <Step title="Design your schema">
    Define your GraphQL schema that will be used to integrate your plugin into your federated graph.
    
    [→ Jump to schema design](#design-your-schema)
  </Step>
  <Step title="Generate & Implement">
    Generate Protobuf code with `wgc router plugin generate` and implement your resolvers in Go.
    
    [→ Jump to implementation](#generate-and-implement)
  </Step>
  <Step title="Publish & Deploy">
    Publish your plugin to Cosmo with `wgc router plugin publish` and test via GraphQL queries.
    
    [→ Jump to deployment](#publish-and-deploy)
  </Step>
</Steps>

---

First off, let's get familiar with some terminology we use to describe different parts of the platform:

- **Cosmo Cloud**: Our cloud-hosted platform for publishing and monitoring your subgraphs
- **Supergraph**: The unified graph containing the composition of all your subgraphs
- **Subgraph**: A small part of a supergraph, usually serving a small service contract. For example, "billing"
- **gRPC Subgraph**: A subgraph built with our new gRPC-based tooling that can be run standalone or as a gRPC plugin
- **gRPC Plugin**: A way to run subgraphs created with gRPC alongside the router directly in your infrastructure, no extra deployment required

Now that we have that sorted, let's move onto the good stuff.

## Building Plugins

###  Initialize Plugin

You can create a gRPC plugin using our CLI tool, `wgc`:

```bash
wgc router plugin init starwars
```

You should now have a directory containing a single plugin, `starwars`. We'll go over what each file does soon.

```
starwars
├── Dockerfile
├── generated
│   ├── mapping.json
│   ├── service.proto
│   └── service.proto.lock.json
├── go.mod
├── Makefile
├── README.md
└── src
    ├── main.go
    ├── main_test.go
    └── schema.graphql
```

### Design your schema

The first thing we need to do is take a look at the GraphQL schema in `starwars/src/schema.graphql`. It doesn't contain our schema yet, so we'll start by defining our new service in GraphQL terms.

When you open this file, it will have some placeholder schema inside. You can safely remove all of the content and replace it with the following:

```graphql src/schema.graphql
type Person {
  """
  The name of this person
  """
  name: String!

  """
  The height of the person in centimeters
  """
  height: String!

  """
  The mass of the person in kilograms
  """
  mass: String!

  """
  The hair color of this person. Will be "unknown" if not known or "n/a" if the person does not have hair
  """
  hair_color: String!

  """
  The skin color of this person
  """
  skin_color: String!

  """
  The eye color of this person. Will be "unknown" if not known or "n/a" if the person does not have an eye
  """
  eye_color: String!

  """
  The birth year of the person, using BBY or ABY (Before/After Battle of Yavin)
  """
  birth_year: String!

  """
  The gender of this person. Either "Male", "Female" or "unknown", "n/a" if no gender
  """
  gender: String!
}

type Query {
  """
  get all the people
  """
  people: [Person!]!
}
```

For this example, we won't utilize the entire SWAPI for this tutorial, only the `people` resource and its endpoints.

This schema has a single type, "Person", and a query to get all the people or a specific person by ID.

### Generate and Implement

Now we can use `wgc` again to generate the Protobuf representation of our subgraph and boilerplate code to implement it in Golang.

```bash
wgc router plugin generate ./starwars
```

You'll now see a few new files in the `generated` folder.

```
generated
├── mapping.json
├── service.pb.go
├── service.proto
├── service.proto.lock.json
└── service_grpc.pb.go
```

In short, these files are generated helpers based on the schema we wrote. They help either translate GraphQL operations to gRPC or let you write type-safe resolvers in the plugin itself.


<Note>
  We recommend checking this folder into version control (e.g. Git).
</Note>

Now, let's start implementing our resolvers. After generating, if you open `main.go`, you will see some errors about undefined types. These are remnants from the example schema's resolver, and you can safely delete them to start from scratch.

Here's a starting point for implementing our new resolvers:

```go main.go
package main

import (
	"context"
	"log"
	"net/http"
	"time"

	service "github.com/wundergraph/cosmo/plugin/generated"

	routerplugin "github.com/wundergraph/cosmo/router-plugin"
	"google.golang.org/grpc"
)

// 1. Add a constant that we can use to construct request URLs later
const swapiBaseURL = "https://swapi.dev/api"

func main() {
	pl, err := routerplugin.NewRouterPlugin(func(s *grpc.Server) {
		s.RegisterService(&service.StarwarsService_ServiceDesc, &StarwarsService{
			// 2a. Add an *http.Client with a timeout
			client: &http.Client{
				Timeout: 30 * time.Second,
			},
		})
	})

	if err != nil {
		log.Fatalf("failed to create router plugin: %v", err)
	}

	pl.Serve()
}

// 2b. Add a new *http.Client field to be used by the service.
type StarwarsService struct {
	service.UnimplementedStarwarsServiceServer

	client *http.Client
}

func (s *StarwarsService) QueryPeople(ctx context.Context, req *service.QueryPeopleRequest) (*service.QueryPeopleResponse, error) {
	panic("not implemented")
}
```

This updates the `main.go` that comes with the initial plugin template in a few ways:

1. We add a constant `swapiBaseURL` that we'll later use to construct the URL for the SWAPI API endpoint.
2. In the `StarwarsService` struct, we added a field of type `*http.Client` (2b). 
    - This will hold a persistent HTTP client that our endpoints can use for the whole lifetime of the plugin process.
    - We set a 30-second request timeout. It's important to set this for HTTP clients in Go because the default is unlimited and can lead to resource exhaustion from many pending requests. (2a)
3. We removed resolvers for the old `QueryHello` RPC and a field `nextId` in the `StarwarsService` struct.

If you published this now, the plugin would just panic (exit ungracefully) when we tried to use the `people` query because of the `panic("not implemented")` in the RPC resolver. The plugin would be automatically restarted, but the request would fail. Let's fix that.

<Note>
In the `main()` function, you can use `os.Getenv` or many available configuration libraries for Go to pull info from the environment to configure your service. A good one to start with is [caarlos0/env](https://github.com/caarlos0/env).
</Note>

Next, let's add a struct (Go's most primitive object type) to help us work with SWAPI responses. 

```go main.go
package main

...

type SWAPIPerson struct {
	Name      string `json:"name"`
	Height    string `json:"height"`
	Mass      string `json:"mass"`
	HairColor string `json:"hair_color"`
	SkinColor string `json:"skin_color"`
	EyeColor  string `json:"eye_color"`
	BirthYear string `json:"birth_year"`
	Gender    string `json:"gender"`
}

func main() {
	...
}
```

These types are very similar to those generated for our service, close enough that we could potentially use the generated types directly. But for this example, we'll create a separate type to show what happens if you need more complex mapping from the wrapped API to your service.

Now, let's implement the resolver for our `QueryPeople` RPC. Right now, your resolver should look like this:

```go main.go
func (s *StarwarsService) QueryPeople(ctx context.Context, req *service.QueryPeopleRequest) (*service.QueryPeopleResponse, error) {
	panic("not implemented")
}
```

Here's an implemented version of the `QueryPeople` RPC resolver:

```go main.go
...

func (s *StarwarsService) QueryPeople(ctx context.Context, req *service.QueryPeopleRequest) (*service.QueryPeopleResponse, error) {
	// 1. Create a request to the SWAPI for people
	httpReq, err := http.NewRequestWithContext(ctx, "GET", fmt.Sprintf("%s/people/", swapiBaseURL), nil)
	if err != nil {
		return nil, status.Errorf(codes.Internal, "failed to fetch people: %v", err)
	}

	// 2. Send the request and handle the response
	resp, err := s.client.Do(httpReq)
	if err != nil {
		return nil, status.Errorf(codes.Internal, "failed to fetch people: %v", err)
	}
	defer resp.Body.Close()

	// 3. If the response status is not OK, return an error
	if resp.StatusCode != http.StatusOK {
		return nil, status.Errorf(codes.Internal, "failed to fetch people: SWAPI returned status %d", resp.StatusCode)
	}

	// 4. Decode the response body into a list of SWAPIPerson
	var people []SWAPIPerson
	if err := json.NewDecoder(resp.Body).Decode(&people); err != nil {
		return nil, status.Errorf(codes.Internal, "failed to decode response: %v", err)
	}

	// 5. Convert the []SWAPIPerson to []*service.Person (the type needed for our RPC's return type)
	protoPeople := make([]*service.Person, len(people)) // You can pre-allocate the new slice to the exact length of the people slice, this won't work if you're filtering while iterating.
	for i, person := range people {
		protoPeople[i] = &service.Person{
			Name:      person.Name,
			Height:    person.Height,
			Mass:      person.Mass,
			HairColor: person.HairColor,
			SkinColor: person.SkinColor,
			EyeColor:  person.EyeColor,
			BirthYear: person.BirthYear,
			Gender:    person.Gender,
		}
	}

	// 6. Return a response containing the converted people objects
	return &service.QueryPeopleResponse{
		People: protoPeople,
	}, nil
}

...
```

Lets go over it step by step:

1. Start by setting up a request to fetch the list of people from the SWAPI with HTTP GET to `{swapiBaseURL}/people/`.
2. Perform the request and handle any errors that may occur.
3. Check the response status code and return an error if it's not 200 OK.
4. Decode the JSON response into a slice of `SWAPIPerson` structs.
5. Transform the slice of `SWAPIPerson` structs into a slice of `*service.Person` structs (this type comes from the generated code for your schema)
    - In a more complex program, this is where you would do any transformations needed to produce the expected response from your backend, database, or other source.
    - This method lets you write the GraphQL schema for your client‑facing federated graph in a way that fits that ecosystem, while handling translation from other formats in a fully featured language like Go.
6. Finally, we return a response containing the converted people objects

<Tip>
The errors here come from `google.golang.org/grpc/status` and `google.golang.org/grpc/codes`. They're an idiomatic way to return errors in a gRPC API.
</Tip>

## Publish and Deploy

Now, our plugin is in a semi-working state, and we can publish it to test it out as part of our federated graph.

Using our CLI `wgc`, publish the plugin:

```bash
wgc router plugin publish ./starwars --label team=A
```

<Accordion icon="circle-question-mark" title="How does deployment work?">
    When you run the deploy command, your plugin is built and packaged using the `Dockerfile` in the plugin directory. We then send this image containing your plugin and any other files it may need off to our Cosmo Cloud Registry where it can be pulled by your routers.
    
    Importantly, the router does not run plugins using Docker or in a container, instead we unpack the final target of the image into a working directory and run the plugin directly. This means if your plugin depends on a system dependency, it must be present in your Router image, not the plugin image.
</Accordion>

Congratulations! You've created your first gRPC plugin.  

You'll see the output from a Docker build and push, followed by a successful completion.

If you have a router deployed serving your federated graph, you can now query `people` via GraphQL.

```graphql graphql query
query People {
  people {
    name
    hair_color
  }
}
```

It should return something like:

```json json response
{
  "data": {
    "people": [
      {
        "name": "Luke Skywalker",
        "hair_color": "blond"
      },
      ...
    ]
  }
}
```

<Warning>
If you get an error, check your router logs to see where it might be coming from. If you can't solve it, a complete version of the plugin is linked in the [Appendix](#Appendix).
</Warning>

### Updating the plugin

You can update the schema or the implementation of the plugin by modifying the `schema.graphql` file or the `main.go` file, respectively.

If you update the schema, you need to regenerate the code by running `wgc router plugin generate`.

## What's next?

You can find the full technical documentation for gRPC plugins [here](/router/gRPC/plugins).

Well, in our case, the SWAPI has much more information than just people. It also includes data about vehicles, planets, and species. We could add these entities to our schema and resolve them using our plugin.

In your case, you might add entity resolvers to your plugin's GraphQL schema to see how federation works with gRPC, or create more plugins for other purposes. Plugins aren't just for wrapping HTTP APIs either; you can use the full power of Go to query databases, implement business logic, or do anything else you need.

You can also implement tests for your plugin to ensure it works correctly, you can find an example test in the `src/main_test.go`, you can try updating it to work with the new schema.

## Appendix

<Accordion icon="code" title="Full plugin code">
    ```graphql src/schema.graphql
    type Person {
      """
      The name of this person
      """
      name: String!
    
      """
      The height of the person in centimeters
      """
      height: String!
    
      """
      The mass of the person in kilograms
      """
      mass: String!
    
      """
      The hair color of this person. Will be "unknown" if not known or "n/a" if the person does not have hair
      """
      hair_color: String!
    
      """
      The skin color of this person
      """
      skin_color: String!
    
      """
      The eye color of this person. Will be "unknown" if not known or "n/a" if the person does not have an eye
      """
      eye_color: String!
    
      """
      The birth year of the person, using BBY or ABY (Before/After Battle of Yavin)
      """
      birth_year: String!
    
      """
      The gender of this person. Either "Male", "Female" or "unknown", "n/a" if no gender
      """
      gender: String!
    }
    
    type Query {
      """
      get all the people
      """
      people: [Person!]!
    }
    ```
    ```go src/main.go
    package main
        
    import (
    	"context"
    	"encoding/json"
    	"fmt"
    	"log"
    	"net/http"
    	"time"
        
    	service "github.com/wundergraph/cosmo/plugin/generated"
        
    	routerplugin "github.com/wundergraph/cosmo/router-plugin"
    	"google.golang.org/grpc"
    	"google.golang.org/grpc/codes"
    	"google.golang.org/grpc/status"
    )
        
    const swapiBaseURL = "https://swapi.dev/api"
        
    type SWAPIPerson struct {
    	Name      string `json:"name"`
    	Height    string `json:"height"`
    	Mass      string `json:"mass"`
    	HairColor string `json:"hair_color"`
    	SkinColor string `json:"skin_color"`
    	EyeColor  string `json:"eye_color"`
    	BirthYear string `json:"birth_year"`
    	Gender    string `json:"gender"`
    }
        
    func main() {
    	pl, err := routerplugin.NewRouterPlugin(func(s *grpc.Server) {
    		s.RegisterService(&service.StarwarsService_ServiceDesc, &StarwarsService{
    			client: &http.Client{
    				Timeout: 30 * time.Second,
    			},
    		})
    	})
        
    	if err != nil {
    		log.Fatalf("failed to create router plugin: %v", err)
    	}
        
    	pl.Serve()
    }
        
    type StarwarsService struct {
    	service.UnimplementedStarwarsServiceServer
    	client *http.Client
    }
        
    func (s *StarwarsService) QueryPeople(ctx context.Context, req *service.QueryPeopleRequest) (*service.QueryPeopleResponse, error) {
    	// 1. Create a request to the SWAPI for people
    	httpReq, err := http.NewRequestWithContext(ctx, "GET", fmt.Sprintf("%s/people/", swapiBaseURL), nil)
    	if err != nil {
    		return nil, status.Errorf(codes.Internal, "failed to fetch people: %v", err)
    	}
        
    	// 2. Send the request and handle the response
    	resp, err := s.client.Do(httpReq)
    	if err != nil {
    		return nil, status.Errorf(codes.Internal, "failed to fetch people: %v", err)
    	}
    	defer resp.Body.Close()
        
    	// 3. If the response status is not OK, return an error
    	if resp.StatusCode != http.StatusOK {
    		return nil, status.Errorf(codes.Internal, "failed to fetch people: SWAPI returned status %d", resp.StatusCode)
    	}
        
    	// 4. Decode the response body into a list of SWAPIPerson
    	var people []SWAPIPerson
    	if err := json.NewDecoder(resp.Body).Decode(&people); err != nil {
    		return nil, status.Errorf(codes.Internal, "failed to decode response: %v", err)
    	}
        
    	// 5. Convert the []SWAPIPerson to []*service.Person (the type needed for our RPC's return type)
    	protoPeople := make([]*service.Person, len(people)) // You can pre-allocate the new slice to the exact length of the people slice, this won't work if you're filtering while iterating.
    	for i, person := range people {
    		protoPeople[i] = &service.Person{
    			Name:      person.Name,
    			Height:    person.Height,
    			Mass:      person.Mass,
    			HairColor: person.HairColor,
    			SkinColor: person.SkinColor,
    			EyeColor:  person.EyeColor,
    			BirthYear: person.BirthYear,
    			Gender:    person.Gender,
    		}
    	}
        
    	// 6. Return a response containing the converted people objects
    	return &service.QueryPeopleResponse{
    		People: protoPeople,
    	}, nil
    }
    ```
</Accordion>
