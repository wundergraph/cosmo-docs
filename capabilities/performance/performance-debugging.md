# Performance Debugging

## Metadata

| Field | Value |
|-------|-------|
| **Capability ID** | `cap-perf-005` |
| **Category** | Performance |
| **Status** | GA |
| **Availability** | Free / Pro / Enterprise |
| **Related Capabilities** | `cap-perf-003` (Cache Warmer) |

---

## Quick Reference

### Name
Performance Debugging

### Tagline
Identify and resolve GraphQL performance bottlenecks.

### Elevator Pitch
Performance Debugging provides deep visibility into every phase of GraphQL request processing through OpenTelemetry tracing. See exactly how much time is spent on authentication, parsing, planning, and execution - and identify whether cache hits are optimizing your query plans. Pinpoint bottlenecks in minutes, not hours.

---

## Problem & Solution

### The Problem
When GraphQL requests are slow, identifying the root cause is challenging. Is the delay in query planning? Subgraph execution? Authentication? Without detailed timing breakdowns, developers resort to guesswork and time-consuming trial-and-error debugging. Federation adds complexity, as requests may touch multiple subgraphs with varying performance characteristics.

### The Solution
Cosmo's Performance Debugging leverages OpenTelemetry to provide detailed span data for every phase of request processing. View timing breakdowns in Cosmo Studio's trace view to instantly identify whether slowness stems from planning, execution, or downstream services. Track cache hit rates to ensure query plan caching is working effectively.

### Before & After

| Before Cosmo | With Cosmo Performance Debugging |
|--------------|----------------------------------|
| Guessing where latency originates | Precise timing breakdown per phase |
| No visibility into planning vs execution time | Separate spans for planning and execution |
| Unknown if query plan cache is working | `enginePlanCacheHit` attribute shows cache status |
| Time-consuming performance investigations | Pinpoint bottlenecks from trace view |

---

## Key Benefits

1. **Phase-Level Visibility**: Separate timing for authentication, parsing/validation, planning, and execution phases.
2. **Cache Hit Tracking**: The `enginePlanCacheHit` attribute reveals whether query plans are being served from cache.
3. **ART Awareness**: Track when Advanced Request Tracing (ART) is enabled, which adds overhead useful for debugging but not production.
4. **Zero-Code Instrumentation**: OpenTelemetry spans are automatically generated by the router with no additional setup.
5. **Studio Integration**: View traces directly in Cosmo Studio with visual timelines and span hierarchies.

---

## Target Audience

### Primary Persona
- **Role**: Backend Developer / SRE
- **Pain Points**: Slow GraphQL queries with unknown root cause, difficulty identifying federation performance issues
- **Goals**: Quickly diagnose and resolve performance bottlenecks

### Secondary Personas
- Platform engineers optimizing router performance
- DevOps teams monitoring SLA compliance
- Engineering managers tracking system health metrics

---

## Use Cases

### Use Case 1: Cold Cache Investigation
**Scenario**: Users report intermittent slow responses that seem to resolve after the first few requests.
**How it works**: Open Cosmo Studio trace view and filter for slow operations. Check the `enginePlanCacheHit` attribute - if it shows `false`, the query plan is being computed fresh. Multiple cache misses indicate cold cache issues or cache eviction.
**Outcome**: Identification of query plan cache misses leading to implementation of Cache Warmer for critical queries.

### Use Case 2: Subgraph Performance Isolation
**Scenario**: A complex query spanning five subgraphs has inconsistent latency.
**How it works**: View the Operation - Execution span in the trace. Expand to see individual subgraph fetch times. Identify the specific subgraph adding significant latency.
**Outcome**: Targeted optimization of the slow subgraph resolver, reducing overall query latency by 60%.

### Use Case 3: Planning vs Execution Analysis
**Scenario**: A team needs to understand if slow queries are due to complex planning or slow data fetching.
**How it works**: Compare the Operation - Planning span duration against the Operation - Execution span. High planning time suggests schema or query complexity issues. High execution time points to subgraph or database performance.
**Outcome**: Data-driven decisions on whether to optimize the query structure or backend services.

---

## Technical Summary

### How It Works
The router automatically generates OpenTelemetry spans for each phase of request processing:
1. **Authenticate** (optional): Time spent validating requests against authentication providers
2. **Operation - Parse and Validate**: Parsing variables, query body, and schema validation
3. **Operation - Planning**: Building the optimized query plan, including normalization
4. **Operation - Execution**: Fetching data from subgraphs and aggregating responses

### Key Technical Features
- OpenTelemetry-compatible span generation
- `enginePlanCacheHit` attribute for cache monitoring
- `engineRequestTracingEnabled` attribute for ART detection
- Integration with Cosmo Studio trace viewer
- Export to external observability platforms (Jaeger, Zipkin, etc.)

### Integration Points
- Cosmo Studio for native trace visualization
- OpenTelemetry collectors
- Jaeger, Zipkin, and other tracing backends
- Prometheus/Grafana for metrics dashboards

### Requirements & Prerequisites
- Router with OpenTelemetry enabled (default configuration)
- Access to Cosmo Studio or external tracing backend
- Understanding of GraphQL request lifecycle

---

## Span Reference

| Span Name | Description | Key Attributes |
|-----------|-------------|----------------|
| **Authenticate** | Authentication provider validation (optional) | Error status indicates unauthorized |
| **Operation - Parse and Validate** | Query parsing and schema validation | - |
| **Operation - Planning** | Query plan construction | `enginePlanCacheHit`, `engineRequestTracingEnabled` |
| **Operation - Execution** | Subgraph data fetching and aggregation | Per-subgraph timing |

---

## Documentation References

- Primary docs: `/docs/router/performance-debugging`
- Tracing configuration: `/docs/router/observability/tracing`
- Advanced Request Tracing: `/docs/router/advanced-request-tracing-art`
- Studio tracing view: `/docs/studio/tracing`

---

## Keywords & SEO

### Primary Keywords
- GraphQL performance debugging
- Query plan tracing
- OpenTelemetry GraphQL

### Secondary Keywords
- Federation performance
- Subgraph latency
- Cache hit monitoring

### Related Search Terms
- How to debug slow GraphQL queries
- GraphQL tracing setup
- Federation performance optimization

---

## Version History

| Date | Version | Changes |
|------|---------|---------|
| 2025-01-14 | 1.0 | Initial capability documentation |
